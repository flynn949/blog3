colnames(widthvals) <- mutants
heightvals <- as.data.frame(list_of_draws$height[1:n_draws,])
colnames(heightvals) <- mutants
conc_detailed <- seq(60,80,0.1)
#Create a 3D array of draw-mutant-concentration, filled with the probability of success.
curves <- array(NA, dim=c(n_draws, n_mutants, length(conc_detailed)), dimnames = list(draws, mutants, conc_detailed))
for (i in 1:n_draws){
for (j in 1:n_mutants){
for (k in 1:length(conc_detailed)){
curves[i,j,k] <- gaussian(height = heightvals[i,j], centre = centrevals[i,j], width = widthvals[i,j], x = conc_detailed[k])
}
}
}
#Turn the array into a data frame in tidy format - the fastest way is to use the melt function from reshape2 (unfortunately tidyr's 'gather' does not work on arrays)
library(reshape2)
curves_c <- melt(curves)
detach(package:reshape2)
colnames(curves_c) <- c("draw", "mutant", "conc", "prob")
draws_to_plot <- 12
centrepositions <- centrevals[1:draws_to_plot,] %>%
mutate(draw = draws[1:draws_to_plot]) %>%
gather(mutant, centre,-draw)
mutants_to_compare <- c("A", "C")
curves_c %>%
filter(mutant %in% mutants_to_compare) %>%
filter(draw %in% draws[1:draws_to_plot]) %>%
ggplot()+
aes(x = conc, y = prob, group = mutant, colour = mutant)+
geom_line()+
geom_vline(data = centrepositions %>% filter(mutant %in% mutants_to_compare), aes(xintercept = centre, colour = mutant))+
facet_wrap(~draw)+
scale_colour_manual(values = c("blue", "darkorange"))+
labs(title = "Fitted curves for mutants A and C: 12 posterior draws",x = "conc", y = "Probability of success")+
theme(legend.position = "bottom")
curves_c %>%
filter(mutant %in% mutants_to_compare) %>%
ggplot()+
aes(x = conc, y = prob, group = interaction(mutant, draw), colour = mutant)+
geom_line(alpha = 0.3)+
scale_colour_manual(values = c("blue", "darkorange"))+
labs(title = "Fitted curves for mutants A and C: 200 posterior draws", x = "conc", y = "Probability of success")+
theme(legend.position = "bottom")
centre_a.all <- list_of_draws$centre[,1]
centre_c.all <- list_of_draws$centre[,3]
sum(centre_a.all < centre_c.all)/length(centre_a.all)
centre_a.all <- list_of_draws$centre[,1]
centre_c.all <- list_of_draws$centre[,3]
sum(centre_a.all > centre_c.all)/length(centre_a.all)
fPaste <- function(vec) sub(",\\s+([^,]+)$", " and \\1", toString(vec)) #A function from stack exchange
fPaste(mutants_to_compare)
compare_mutants_plot <- function(mutantlist, curvedata = curves_c, centrepos = centrepositions){
outplot <- curvedata %>%
filter(mutant %in% mutantlist) %>%
filter(draw %in% draws[1:draws_to_plot]) %>%
ggplot()+
aes(x = conc, y = prob, group = mutant, colour = mutant)+
geom_line()+
geom_vline(data = centrepos %>% filter(mutant %in% mutantlist), aes(xintercept = centre, colour = mutant))+
facet_wrap(~draw)+
scale_colour_manual(values = c("blue", "darkorange"))+
labs(title = paste0("Fitted curves for mutants ", fPaste(mutantlist, ": 12 posterior draws")),x = "conc", y = "Probability of success")+
theme(legend.position = "bottom")
return(outplot)
}
mutants_to_compare <- c("A", "C")
compare_mutants_plot(mutants_to_compare)
compare_mutants_plot <- function(mutantlist, curvedata = curves_c, centrepos = centrepositions){
outplot <- curvedata %>%
filter(mutant %in% mutantlist) %>%
filter(draw %in% draws[1:draws_to_plot]) %>%
ggplot()+
aes(x = conc, y = prob, group = mutant, colour = mutant)+
geom_line()+
geom_vline(data = centrepos %>% filter(mutant %in% mutantlist), aes(xintercept = centre, colour = mutant))+
facet_wrap(~draw)+
scale_colour_manual(values = c("blue", "darkorange"))+
labs(title = paste0("Fitted curves for mutants ", fPaste(mutantlist), ": 12 posterior draws"),x = "conc", y = "Probability of success")+
theme(legend.position = "bottom")
return(outplot)
}
mutants_to_compare <- c("A", "C")
compare_mutants_plot(mutants_to_compare)
compare_mutants_plot(c("A", "C"))
compare_mutants_plot <- function(mutantlist, draws_to_plot=12, centre_draws = centrevals, curvedata = curves_c){
centrepositions <- centre_draws[1:draws_to_plot,] %>%
mutate(draw = draws[1:draws_to_plot]) %>%
gather(mutant, centre,-draw)
outplot <- curvedata %>%
filter(mutant %in% mutantlist) %>%
filter(draw %in% draws[1:draws_to_plot]) %>%
ggplot()+
aes(x = conc, y = prob, group = mutant, colour = mutant)+
geom_line()+
geom_vline(data = centrepositions %>% filter(mutant %in% mutantlist), aes(xintercept = centre, colour = mutant))+
facet_wrap(~draw)+
scale_colour_manual(values = c("blue", "darkorange"))+
labs(title = paste0("Fitted curves for mutants ", fPaste(mutantlist), ": 12 posterior draws"),x = "conc", y = "Probability of success")+
theme(legend.position = "bottom")
return(outplot)
}
compare_mutants_plot(c("A", "C"))
compare_mutants_plot <- function(mutantlist, draws_to_plot=12, centre_draws = centrevals, curvedata = curves_c){
centrepositions <- centre_draws[1:draws_to_plot,] %>%
mutate(draw = draws[1:draws_to_plot]) %>%
gather(mutant, centre,-draw)
outplot <- curvedata %>%
filter(mutant %in% mutantlist) %>%
filter(draw %in% draws[1:draws_to_plot]) %>%
ggplot()+
aes(x = conc, y = prob, group = mutant, colour = mutant)+
geom_line()+
geom_vline(data = centrepositions %>% filter(mutant %in% mutantlist), aes(xintercept = centre, colour = mutant))+
facet_wrap(~draw)+
scale_colour_manual(values = c("blue", "darkorange"))+
labs(title = paste0("Fitted curves for mutants ", fPaste(mutantlist), ": ", draws_to_plot, " posterior draws"),x = "conc", y = "Probability of success")+
theme(legend.position = "bottom")
return(outplot)
}
compare_mutants_plot(c("A", "C"))
compare_mutants_plot(c("A", "C"), 10)
compare_mutants_plot(c("A", "C"), 12)
compare_mutants_plot(c("E", "F"), 12)
overlay_mutants_plot <- function(mutantlist, draws_to_plot=200, curvedata = curves_c){
outplot <- curvedata %>%
filter(mutant %in% mutantlist) %>%
ggplot()+
aes(x = conc, y = prob, group = interaction(mutant, draw), colour = mutant)+
geom_line(alpha = 0.3)+
scale_colour_manual(values = c("blue", "darkorange"))+
labs(title = paste0("Fitted curves for mutants ", fPaste(mutantlist), ": ", draws_to_plot, " posterior draws"), x = "conc", y = "Probability of success")+
theme(legend.position = "bottom")
return(outplot)
}
overlay_mutants_plot(c("A", "C"))
compare_mutants_plot(c("E", "F"), 12)
overlay_mutants_plot(c("E", "F"))
library(shinystan)
launch_shinystan(fit)
fit <- stan(model_code = "mutant_model.stan",
model_name = "example",
data = dat_allmutants,
iter = 2000, warmup = 1000, chains = 4, cores = 4, sample_file = 'multi_mutants.csv',
verbose = FALSE)
fit <- stan(model_code = "mutant_model.stan",
model_name = "example",
data = dat_allmutants,
iter = 2000, warmup = 1000, chains = 4, cores = 4, sample_file = 'multi_mutants.csv',
verbose = FALSE)
fit <- stan(model_code = "mutant_model.stan",
model_name = "example",
data = dat_allmutants,
iter = 2000, warmup = 1000, chains = 4, cores = 4, sample_file = 'multi_mutants.csv',
verbose = FALSE)
fit <- stan(model_code = "mutant_model.stan",
model_name = "example",
data = dat_allmutants,
iter = 2000, warmup = 1000, chains = 4, cores = 4, sample_file = 'multi_mutants.csv',
verbose = FALSE)
getwd()
fit <- stan(model_code = "mutant_model.stan",
model_name = "example",
data = dat_allmutants,
iter = 2000, warmup = 1000, chains = 4, cores = 4, sample_file = 'multi_mutants.csv',
verbose = FALSE)
mean(centre_a.all - centre_c.all)
round(sd(centre_a.all - centre_c.all),2)
round(mean(centre_a.all - centre_c.all),2)
round(sd(centre_a.all - centre_c.all),2)
min(centre_a.all - centre_c.all)
max(centre_a.all - centre_c.all)
data.frame("difference" = centre_a.all - centre_c.all) %>%
ggplot()+
aes(x = difference)+
geom_density()
match("A", mutants)
mutants[match("A", mutants)]
difference_plot <- function(first_mutant = "A", second_mutant = "C", parameter = "centre", drawlist = list_of_draws){
first = match(first_mutant, mutants)
second = match(second_mutant, mutants)
first_mutant_draws <- drawlist[[parameter]][,first]
second_mutant_draws <- drawlist[[parameter]][,second]
outplot <- data.frame("difference" = first_mutant_draws - second_mutant_draws) %>%
ggplot()+
aes(x = difference)+
geom_density()
return(outplot)
}
difference_plot("A", "C")
difference_plot <- function(first_mutant = "A", second_mutant = "C", parameter = "centre", drawlist = list_of_draws){
first = match(first_mutant, mutants)
second = match(second_mutant, mutants)
first_mutant_draws <- drawlist[[parameter]][,first]
second_mutant_draws <- drawlist[[parameter]][,second]
outplot <- data.frame("difference" = first_mutant_draws - second_mutant_draws) %>%
ggplot()+
aes(x = difference)+
geom_density(size = 2, colour = "blue")
return(outplot)
}
difference_plot("E", "F")
difference_plot <- function(first_mutant = "A", second_mutant = "C", parameter = "centre", drawlist = list_of_draws){
first = match(first_mutant, mutants)
second = match(second_mutant, mutants)
first_mutant_draws <- drawlist[[parameter]][,first]
second_mutant_draws <- drawlist[[parameter]][,second]
outplot <- data.frame("difference" = first_mutant_draws - second_mutant_draws) %>%
ggplot()+
aes(x = difference)+
stat_density(geom = "line", colour = "blue")
return(outplot)
}
difference_plot("A", "C")
difference_plot("E", "F")
difference_plot <- function(first_mutant = "A", second_mutant = "C", parameter = "centre", drawlist = list_of_draws){
first = match(first_mutant, mutants)
second = match(second_mutant, mutants)
first_mutant_draws <- drawlist[[parameter]][,first]
second_mutant_draws <- drawlist[[parameter]][,second]
outplot <- data.frame("difference" = first_mutant_draws - second_mutant_draws) %>%
ggplot()+
aes(x = difference)+
stat_density(geom = "line", colour = "blue")+
labs(title = paste0("Distribution of differences within draws for mutants", first_mutant, " and ", second_mutant, " ", parameter, " values"))
return(outplot)
}
difference_plot("A", "C")
difference_plot <- function(first_mutant = "A", second_mutant = "C", parameter = "centre", drawlist = list_of_draws){
first = match(first_mutant, mutants)
second = match(second_mutant, mutants)
first_mutant_draws <- drawlist[[parameter]][,first]
second_mutant_draws <- drawlist[[parameter]][,second]
outplot <- data.frame("difference" = first_mutant_draws - second_mutant_draws) %>%
ggplot()+
aes(x = difference)+
stat_density(geom = "line", colour = "blue")+
labs(title = paste0("Distribution of differences within draws for mutants ", first_mutant, " and ", second_mutant, " ", parameter, " values"))
return(outplot)
}
difference_plot("A", "C")
difference_plot("A", "C")
difference_plot <- function(first_mutant = "A", second_mutant = "C", parameter = "centre", drawlist = list_of_draws){
first = match(first_mutant, mutants)
second = match(second_mutant, mutants)
first_mutant_draws <- drawlist[[parameter]][,first]
second_mutant_draws <- drawlist[[parameter]][,second]
outplot <- data.frame("difference" = first_mutant_draws - second_mutant_draws) %>%
ggplot()+
aes(x = difference)+
stat_density(geom = "line", colour = "blue")+
labs(title = paste0("Distribution of differences of mutants ", first_mutant, " and ", second_mutant, " ", parameter, " values: 4000 posterior draws"), xlab = "Difference")
return(outplot)
}
difference_plot("A", "C")
install.packages("blogdown")
getwd()
install.packages("Hugo")
library(rstan)
install.packages("rstan")
library(blogdown)
setwd("~/blog3/content/post")
serve_site()
serve_site()
knitr::opts_chunk$set(echo = TRUE)
power_simulation <- function(n_tutored = 50, n_untutored = 450, tutoring_effect, sigma_secondsession, beta0 = 58, beta1 = 0.9, marks_sd = 12){
#Assign aptitude scores and generate first session marks
nstudents <- n_tutored + n_untutored
aptitude <- sort(rnorm(nstudents, 0, 1))
students <- data.frame(aptitude)
students$first_session <- rnorm(nstudents, students$aptitude*marks_sd + 60, 2)
students <- students[order(students$first_session),]
#Randomly assign tutoring to 50% of students in the bottom n_tutored*2 of first session marks.
tutored.indices <- sample(seq(1,n_tutored*2), n_tutored)
tutored <- rep(0, nstudents)
tutored[tutored.indices] <- 1
students$tutored <- tutored
#Generate second session marks from aptitude, with a bump in marks for those who were tutored
students$second_session <- rnorm(nstudents, beta0 + beta1*aptitude*marks_sd + tutoring_effect*students$tutored, sigma_secondsession)
#Fit  a linear regression to get the p-value on the tutoring effect estimate.
lmod <- summary(lm(second_session ~ first_session + tutored, data = students))
return(lmod$coefficients[3,4]) #The pvalue for the tutoring_effect estimate.
}
pvals <- replicate(10000, power_simulation(n_tutored = 50, n_untutored = 450, tutoring_effect = 1, sigma_secondsession = 2))
mean(pvals <= 0.05)
power_simulation <- function(n_tutored = 50, n_untutored = 450, tutoring_effect, sigma_secondsession, beta0 = 58, beta1 = 0.9, marks_sd = 12){
#Assign aptitude scores and generate first session marks
nstudents <- n_tutored + n_untutored
aptitude <- rnorm(nstudents, 0, 1)
students <- data.frame(aptitude)
students$first_session <- rnorm(nstudents, students$aptitude*marks_sd + 60, 2)
students <- students[order(students$first_session),]
#Randomly assign tutoring to 50% of students in the bottom n_tutored*2 of first session marks.
tutored.indices <- sample(seq(1,n_tutored*2), n_tutored)
tutored <- rep(0, nstudents)
tutored[tutored.indices] <- 1
students$tutored <- tutored
#Generate second session marks from aptitude, with a bump in marks for those who were tutored
students$second_session <- rnorm(nstudents, beta0 + beta1*aptitude*marks_sd + tutoring_effect*students$tutored, sigma_secondsession)
#Fit  a linear regression to get the p-value on the tutoring effect estimate.
lmod <- summary(lm(second_session ~ first_session + tutored, data = students))
return(lmod$coefficients[3,4]) #The pvalue for the tutoring_effect estimate.
}
pvals <- replicate(10000, power_simulation(n_tutored = 50, n_untutored = 450, tutoring_effect = 1, sigma_secondsession = 2))
mean(pvals <= 0.05)
n_tutored = 50
n_untutored = 450
nstudents = 500
aptitude <- rnorm(nstudents, 0, 1)
students <- data.frame(aptitude)
View(students)
students$first_session <- rnorm(nstudents, students$aptitude*12 + 60, 2)
View(students)
students <- students[order(students$first_session),]
View(students)
power_simulation <- function(n_tutored = 50, n_untutored = 450, tutoring_effect, sigma_secondsession, beta0 = 58, beta1 = 0.9, marks_sd = 12){
#Assign aptitude scores and generate first session marks
nstudents <- n_tutored + n_untutored
aptitude <- rnorm(nstudents, 0, 1)
students <- data.frame(aptitude)
students$first_session <- rnorm(nstudents, students$aptitude*marks_sd + 60, 2)
students <- students[order(students$first_session),]
#Randomly assign tutoring to 50% of students in the bottom n_tutored*2 of first session marks.
tutored.indices <- sample(seq(1,n_tutored*2), n_tutored)
tutored <- rep(0, nstudents)
tutored[tutored.indices] <- 1
students$tutored <- tutored
#Generate second session marks from aptitude, with a bump in marks for those who were tutored
students$second_session <- rnorm(nstudents, beta0 + beta1*students$aptitude*marks_sd + tutoring_effect*students$tutored, sigma_secondsession)
#Fit  a linear regression to get the p-value on the tutoring effect estimate.
lmod <- summary(lm(second_session ~ first_session + tutored, data = students))
return(lmod$coefficients[3,4]) #The pvalue for the tutoring_effect estimate.
}
pvals <- replicate(10000, power_simulation(n_tutored = 50, n_untutored = 450, tutoring_effect = 1, sigma_secondsession = 2))
mean(pvals <= 0.05)
power_simulation <- function(n_tutored = 50, n_untutored = 450, tutoring_effect, sigma_secondsession, beta0 = 58, beta1 = 0.9, marks_sd = 12){
#Assign aptitude scores and generate first session marks
nstudents <- n_tutored + n_untutored
aptitude <- rnorm(nstudents, 0, 1)
students <- data.frame(aptitude)
students$first_session <- rnorm(nstudents, students$aptitude*marks_sd + 60, 2)
students <- students[order(students$first_session),]
#Randomly assign tutoring to 50% of students in the bottom n_tutored*2 of first session marks.
tutored.indices <- sample(seq(1,n_tutored*2), n_tutored)
tutored <- rep(0, nstudents)
tutored[tutored.indices] <- 1
students$tutored <- tutored
#Generate second session marks from aptitude, with a bump in marks for those who were tutored
students$second_session <- rnorm(nstudents, beta0 + beta1*students$aptitude*marks_sd + tutoring_effect*students$tutored, sigma_secondsession)
#Fit  a linear regression to get the p-value on the tutoring effect estimate.
lmod <- summary(lm(second_session ~ first_session + tutored, data = students))
return(lmod$coefficients[3,4]) #The pvalue for the tutoring_effect estimate.
}
pvals <- replicate(10000, power_simulation(n_tutored = 50, n_untutored = 450, tutoring_effect = 1, sigma_secondsession = 2))
mean(pvals <= 0.05)
power_simulation <- function(n_tutored = 50, n_untutored = 450, tutoring_effect, sigma_secondsession, beta0 = 58, beta1 = 0.9, marks_sd = 12, method = "pval"){
#Assign aptitude scores and generate first session marks
nstudents <- n_tutored + n_untutored
aptitude <- rnorm(nstudents, 0, 1)
students <- data.frame(aptitude)
students$first_session <- rnorm(nstudents, students$aptitude*marks_sd + 60, 2)
students <- students[order(students$first_session),]
#Randomly assign tutoring to 50% of students in the bottom n_tutored*2 of first session marks.
tutored.indices <- sample(seq(1,n_tutored*2), n_tutored)
tutored <- rep(0, nstudents)
tutored[tutored.indices] <- 1
students$tutored <- tutored
#Generate second session marks from aptitude, with a bump in marks for those who were tutored
students$second_session <- rnorm(nstudents, beta0 + beta1*students$aptitude*marks_sd + tutoring_effect*students$tutored, sigma_secondsession)
#Fit  a linear regression to get the p-value on the tutoring effect estimate.
lmod <- summary(lm(second_session ~ first_session + tutored, data = students))
if (method == "pval"){return(lmod$coefficients[3,4]) #The pvalue for the tutoring_effect estimate.
#An option to return the coefficient value only if it is significant.
} else if (method == "coeff" & lmod$coefficients[3,4] < 0.05){return(lmod$coefficients[3,1])
} else if (method == "coeff" & lmod$coefficients[3,4] >= 0.05){return(NA)
}
pvals <- replicate(10000, power_simulation(n_tutored = 50, n_untutored = 450, tutoring_effect = 1, sigma_secondsession = 2))
mean(pvals < 0.05)
power_simulation <- function(n_tutored = 50, n_untutored = 450, tutoring_effect, sigma_secondsession, beta0 = 58, beta1 = 0.9, marks_sd = 12, method = "pval"){
#Assign aptitude scores and generate first session marks
nstudents <- n_tutored + n_untutored
aptitude <- rnorm(nstudents, 0, 1)
students <- data.frame(aptitude)
students$first_session <- rnorm(nstudents, students$aptitude*marks_sd + 60, 2)
students <- students[order(students$first_session),]
#Randomly assign tutoring to 50% of students in the bottom n_tutored*2 of first session marks.
tutored.indices <- sample(seq(1,n_tutored*2), n_tutored)
tutored <- rep(0, nstudents)
tutored[tutored.indices] <- 1
students$tutored <- tutored
#Generate second session marks from aptitude, with a bump in marks for those who were tutored
students$second_session <- rnorm(nstudents, beta0 + beta1*students$aptitude*marks_sd + tutoring_effect*students$tutored, sigma_secondsession)
#Fit  a linear regression to get the p-value on the tutoring effect estimate.
lmod <- summary(lm(second_session ~ first_session + tutored, data = students))
if (method == "pval"){return(lmod$coefficients[3,4]) #The pvalue for the tutoring_effect estimate.
#An option to return the coefficient value only if it is significant.
} else if (method == "coeff" & lmod$coefficients[3,4] < 0.05){return(lmod$coefficients[3,1])
} else if (method == "coeff" & lmod$coefficients[3,4] >= 0.05){return(NA)}
}
pvals <- replicate(10000, power_simulation(n_tutored = 50, n_untutored = 450, tutoring_effect = 1, sigma_secondsession = 2))
mean(pvals < 0.05)
tutoring_effects <- replicate(10000, power_simulation(n_tutored = 50, n_untutored = 450, tutoring_effect = 1, sigma_secondsession = 2))
hist(tutoring_effects)
x <- seq(1,100)
y <- rnorm(length(x), x*3+4, 2)
summary(lm(y~x))
servr::daemon_stop("469166808")
thing <- summary(lm(y~x))
thing$coefficients
thing$coefficients[2,1]
knitr::opts_chunk$set(echo = TRUE)
set.seed(42)
n_students <- 500
n_tutoring <- 50
meanmark <- 60.0
marks_sd <- 12.0
aptitude <- rnorm(n_students, 0.0, 1.0)
students <- data.frame(aptitude)
luck <- 2
students$first_session_marks <- rnorm(n_students, students$aptitude*marks_sd + meanmark, luck)
#It is possible for some values to fall off the scale.
students$first_session_marks[students$first_session_marks > 100] <- 100
students$first_session_marks[students$first_session_marks < 0] <- 0
hist(students$first_session_marks, breaks = 15)
students <- students[order(students$first_session_marks),]
n_tutoring_places_accepted <- 0
tutored <- rep(0, n_students)
i <- 1
while (n_tutoring_places_accepted < n_tutoring & i < n_students) {
rval <- runif(1)
if (rval < 0.8 - students$first_session_marks[i]/100){
tutored[[i]] <- 1
n_tutoring_places_accepted <- n_tutoring_places_accepted + 1
}
i <- i + 1
}
students$tutored <- tutored
sum(tutored)
beta_0 <- 58 #This is the mean mark in second session for untutored students
beta_1 <- 0.9
beta_2 <- 3
sigma <- 2 #Luck in second session.
students$second_session_marks.mu <- beta_0 + beta_1*students$aptitude*marks_sd + beta_2*students$tutored
students$second_session_marks <- rnorm(n_students, students$second_session_marks.mu, sigma)
#Once again, it is possible that some values could have fallen off the scale, and this is one simple way to fix that:
students$second_session_marks[students$second_session_marks > 100] <- 100
students$second_session_marks[students$second_session_marks < 0] <- 0
hist(students$second_session_marks, breaks = 15)
plot(students$first_session_marks, students$second_session_marks, col = factor(students$tutored, levels = c(0,1)))
regression_model <- lm(second_session_marks ~ first_session_marks + tutored, data = students)
summary(regression_model)
regression_model$coefficients[3,1]
regression_model$coefficients
thing <- summary(regression_model)
thing$coefficients[3,1]
thing$coefficients
nstudents = 500
n_tutored = 50
n_untutored = 450
knitr::opts_chunk$set(echo = TRUE)
aptitude <- rnorm(nstudents, 0, 1)
students <- data.frame(aptitude)
students$first_session <- rnorm(nstudents, students$aptitude*marks_sd + 60, 2)
students <- students[order(students$first_session),]
#Randomly assign tutoring to 50% of students in the bottom n_tutored*2 of first session marks.
tutored.indices <- sample(seq(1,n_tutored*2), n_tutored)
tutored <- rep(0, nstudents)
tutored[tutored.indices] <- 1
students$tutored <- tutored
#Generate second session marks from aptitude, with a bump in marks for those who were tutored
students$second_session <- rnorm(nstudents, beta0 + beta1*students$aptitude*marks_sd + tutoring_effect*students$tutored, sigma_secondsession)
students <- data.frame(aptitude)
students$first_session <- rnorm(nstudents, students$aptitude*12 + 60, 2)
students <- students[order(students$first_session),]
#Randomly assign tutoring to 50% of students in the bottom n_tutored*2 of first session marks.
tutored.indices <- sample(seq(1,n_tutored*2), n_tutored)
tutored <- rep(0, nstudents)
tutored[tutored.indices] <- 1
students$tutored <- tutored
students$second_session <- rnorm(nstudents, 58 + 0.9*students$aptitude*12 + 1*students$tutored, 12)
#Fit  a linear regression to get the p-value on the tutoring effect estimate.
lmod <- summary(lm(second_session ~ first_session + tutored, data = students))
lmod$coefficients[3,4]
lmod
lmod$coefficients[3,1]
power_simulation <- function(n_tutored = 50, n_untutored = 450, tutoring_effect, sigma_secondsession, beta0 = 58, beta1 = 0.9, marks_sd = 12, method = "pval"){
#Assign aptitude scores and generate first session marks
nstudents <- n_tutored + n_untutored
aptitude <- rnorm(nstudents, 0, 1)
students <- data.frame(aptitude)
students$first_session <- rnorm(nstudents, students$aptitude*marks_sd + 60, 2)
students <- students[order(students$first_session),]
#Randomly assign tutoring to 50% of students in the bottom n_tutored*2 of first session marks.
tutored.indices <- sample(seq(1,n_tutored*2), n_tutored)
tutored <- rep(0, nstudents)
tutored[tutored.indices] <- 1
students$tutored <- tutored
#Generate second session marks from aptitude, with a bump in marks for those who were tutored
students$second_session <- rnorm(nstudents, beta0 + beta1*students$aptitude*marks_sd + tutoring_effect*students$tutored, sigma_secondsession)
#Fit  a linear regression to get the p-value on the tutoring effect estimate.
lmod <- summary(lm(second_session ~ first_session + tutored, data = students))
if (method == "pval"){return(lmod$coefficients[3,4]) #The pvalue for the tutoring_effect estimate.
#An option to return the coefficient value only if it is significant.
} else if (method == "coeff" & lmod$coefficients[3,4] < 0.05){return(lmod$coefficients[3,1])
} else if (method == "coeff" & lmod$coefficients[3,4] >= 0.05){return(NA)}
}
pvals <- replicate(10000, power_simulation(n_tutored = 50, n_untutored = 450, tutoring_effect = 1, sigma_secondsession = 2))
mean(pvals < 0.05)
tutoring_effects <- replicate(10000, power_simulation(n_tutored = 50, n_untutored = 450, tutoring_effect = 1, sigma_secondsession = 2, method = "coeff"))
hist(tutoring_effects)
library(blogdown)
serve_site()
serve_site()
serve_site()
